///2020-05-06 23:39 開始看 23:40寫input
///24:11寫出DP版,但不對,
///24:18我亂了, 放棄 24:23再回來試試
///24:33 ok
#include <stdio.h>
int ans[1000001];
int totalAB(int n)
{///24:29 試寫很幾個數字後,找到規律 24:33亂試出來了...
    int w=n-3;
    if(w%2==0) return w*(w/2+1)/2;///三角形
    else return (w+1)*(w+1)/2/2;///梯形
//    return (w+1)*((w+1)/2)/2;
}
int totalABbad(int n)
{///c: n, b: n-1, a: n-2...2, 總數是n-2-1 (i:1)
    ///      n-2, a: n-3...3, n-3-2
    ///      n-3, a: n-4...4, n-4-3, 最後a要大於0
    ///                       n-i-1-i > 0
    ///                       n-1 > 2i    ...(i:
    ///                       (n-1)/2 > i
    ///所以是 n-1... (n-1)/2
    ///24:03想梯形公式的上底、下底、高
    int count=0;///24:14for迴圈試試
    for(int i=1; i<=(n-1)/2.0; i++) count++;
    return count;
    float bound=(n-1)/2.0;///如果有小數點,答案是(n-1)/2
    ///如果是整除,答案是(n-1)/2-1
    if( (n-1)%2==0) return (n-1)/2-1;
    else return (n-1)/2; ///24:09
    ///24:12思考: c:5, b:5-1, a: 2...5-1-1
    ///                b:5-2, a: 3...5-3(不合)
}
int genTable()
{
    ans[0]=0;
    ans[1]=0;
    ans[2]=0;
    ans[3]=0;
    for(int c=4;c<=100;c++){///24:00發現是梯形公式
        ans[c] = ans[c-1] + totalAB(c);
    }
}
int main()
{
    genTable();
    int n;///n: 3...1000,000 所以不能用暴力法 23:41
        ///23:43也就是不能用C(n,3)去暴力試
    while( scanf("%d",&n)==1 ){
        if(n<3) break;
        ///23:42開始想有沒有重覆的解,DP是解法
        ///23:44用例子想規則: 1,2,3(x)
        ///如果先有a,b 2個數,再數學算出第3個的範圍,要扣除a,b
        ///23:45可試
//        int ans=0;
//        for(int a=1; a<=n; a++){///最小邊
//            for(int b=a+1; b<=n; b++){///中邊
//                ///最長邊必須是 c<a+b
//                /// b<c<a+b => (a-1)
//                ///同時, c也要<=n
//                if(n<a+b) ans += a-1;
//                else ans += n-a;
//            }
//        }
        printf("%d\n", ans[n]);///23:50完成, 23:51但錯了
    }///可能有什麼規律,可試一下
}/*
1 2 3 (x) 3:0
1 3 4 (x)
2 3 4 (O) 4:1
2 4 5 (O)
3 4 5 (O) 5:3  可以用DP來解, ans[n-1]有了,
則ans[n] 是 ans[n-1] + 第3邊用到n, 即
*/
